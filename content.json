{"meta":{"title":"欧米伽丶小队长","subtitle":"努力工作，更热爱生活","description":"一个程序猿的笔记+日记","author":"欧米伽丶小队长","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"SSH","slug":"SSH","date":"2019-04-02T07:01:34.000Z","updated":"2019-04-02T08:21:02.233Z","comments":true,"path":"2019/04/02/SSH/","link":"","permalink":"http://yoursite.com/2019/04/02/SSH/","excerpt":"","text":"最近做项目开始接触到SSH相关的东西，在此记录下SSH相关的内容，以作日后参考。我要实现的是：登录到远程服务器，拷贝本地文件到远程服务器，修改远程服务器的环境变量，运行sh文件，将最后的结果文件拷贝到本地。最开始本人使用了图形化工具“FileZila” ，文件的拷贝是方便，但是修改远程服务器的环境变量以及运行sh文件时遇到了问题，无奈最后还是开始学习下SSH命令进行操作。 简介什么是SSH？SSH 为 Secure Shell 的缩写，由 IETF 的网络小组（Network Working Group）所制定；SSH 为建立在应用层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH最初是UNIX系统上的一个程序，后来又迅速扩展到其他操作平台。SSH在正确使用时可弥补网络中的漏洞。SSH客户端适用于多种平台。几乎所有UNIX平台—包括HP-UX、Linux、AIX、Solaris、Digital UNIX、Irix，以及其他平台，都可运行SSH。以上的内容摘抄至百度百科，说白了，SSH是一种网络协议，用于计算机之间的加密登录。至于SSH的加密原理以及工作机制，本文不再详细说明，毕竟小白，就不再班门弄斧了，本文只讲述简单的使用，好在mac系统默认安装了SSH，我们可以直接开始。 登录到远程服务器$ ssh root@192.168.1.68 -p22 $ ssh 用户名@ip地址 -p端口 如果本地用户名与远程用户名一致的话，登录时可以省略用户名。 $ ssh host SSH的默认端口是22，也就是说，你的登录请求会送进远程主机的22端口。使用p参数，可以修改这个端口。此时我们已经成功登录到了远程服务器。 拷贝文件scp是secure copy的简写，用于在Linux下进行远程拷贝文件的命令，和它类似的命令有cp，不过cp只是在本机进行拷贝不能跨服务器，而且scp传输是加密的。可能会稍微影响一下速度。两台主机之间复制文件必需得同时有两台主机的复制执行帐号和操作权限。scp命令参数 1234567891011121314151617-1 强制scp命令使用协议ssh1-2 强制scp命令使用协议ssh2-4 强制scp命令只使用IPv4寻址-6 强制scp命令只使用IPv6寻址-B 使用批处理模式（传输过程中不询问传输口令或短语）-C 允许压缩。（将-C标志传递给ssh，从而打开压缩功能）-p 留原文件的修改时间，访问时间和访问权限。-q 不显示传输进度条。-r 递归复制整个目录。-v 详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。-c cipher 以cipher将数据传输进行加密，这个选项将直接传递给ssh。-F ssh_config 指定一个替代的ssh配置文件，此参数直接传递给ssh。-i identity_file 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。-l limit 限定用户所能使用的带宽，以Kbit/s为单位。-o ssh_option 如果习惯于使用ssh_config(5)中的参数传递方式，-P port 注意是大写的P, port是指定数据传输用到的端口号-S program 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。 scp一般有六种使用方法 本地复制远程文件：（把远程的文件复制到本地） scp root@www.test.com:/val/test/test.tar.gz /val/test/test.tar.gz 远程复制本地文件：（把本地的文件复制到远程主机上） scp /val/test.tar.gz root@www.test.com:/val/test.tar.gz 本地复制远程目录：（把远程的目录复制到本地） scp -r root@www.test.com:/val/test/ /val/test/ 远程复制本地目录：（把本地的目录复制到远程主机上） scp -r /val/test/ root@www.test.com:/val/test/ 本地复制远程文件到指定目录：（把远程的文件复制到本地） scp root@www.test.com:/val/test/test.tar.gz /val/test/ 远程复制本地文件到指定目录：（把本地的文件复制到远程主机上） scp /val/test.tar.gz root@www.test.com:/val/","categories":[],"tags":[{"name":"SSH FTP","slug":"SSH-FTP","permalink":"http://yoursite.com/tags/SSH-FTP/"}]},{"title":"NSDictionary+NSMutableDictionary扩展","slug":"NSDictionary-NSMutableDictionary扩展","date":"2019-04-02T06:23:25.000Z","updated":"2019-04-02T06:27:18.476Z","comments":true,"path":"2019/04/02/NSDictionary-NSMutableDictionary扩展/","link":"","permalink":"http://yoursite.com/2019/04/02/NSDictionary-NSMutableDictionary扩展/","excerpt":"","text":"当我们对NSDictionary进行赋值取值操作的时候，经常会出现因为空值导致的crash，为了避免这一问题，考虑扩展NSDictionary。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#import &quot;NSDictionary+Common.h&quot;#import &lt;objc/runtime.h&gt;// 避免把nil作为 NSDictionary 的 key 或者 value 引起的crash@implementation NSObject (Swizzling)+ (BOOL)gl_swizzleMethod:(SEL)origSel withMethod:(SEL)altSel &#123; Method origMethod = class_getInstanceMethod(self, origSel); Method altMethod = class_getInstanceMethod(self, altSel); if (!origMethod || !altMethod) &#123; return NO; &#125; class_addMethod(self, origSel, class_getMethodImplementation(self, origSel), method_getTypeEncoding(origMethod)); class_addMethod(self, altSel, class_getMethodImplementation(self, altSel), method_getTypeEncoding(altMethod)); method_exchangeImplementations(class_getInstanceMethod(self, origSel), class_getInstanceMethod(self, altSel)); return YES;&#125;+ (BOOL)gl_swizzleClassMethod:(SEL)origSel withMethod:(SEL)altSel &#123; return [object_getClass((id)self) gl_swizzleMethod:origSel withMethod:altSel];&#125;@end@implementation NSDictionary (Common)+ (void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; [self gl_swizzleMethod:@selector(initWithObjects:forKeys:count:) withMethod:@selector(gl_initWithObjects:forKeys:count:)]; [self gl_swizzleClassMethod:@selector(dictionaryWithObjects:forKeys:count:) withMethod:@selector(gl_dictionaryWithObjects:forKeys:count:)]; &#125;);&#125;+ (instancetype)gl_dictionaryWithObjects:(const id [])objects forKeys:(const id&lt;NSCopying&gt; [])keys count:(NSUInteger)cnt &#123; id safeObjects[cnt]; id safeKeys[cnt]; NSUInteger j = 0; for (NSUInteger i = 0; i &lt; cnt; i++) &#123; id key = keys[i]; id obj = objects[i]; if (!key || !obj) &#123; continue; &#125; safeKeys[j] = key; safeObjects[j] = obj; j++; &#125; return [self gl_dictionaryWithObjects:safeObjects forKeys:safeKeys count:j];&#125;- (instancetype)gl_initWithObjects:(const id [])objects forKeys:(const id&lt;NSCopying&gt; [])keys count:(NSUInteger)cnt &#123; id safeObjects[cnt]; id safeKeys[cnt]; NSUInteger j = 0; for (NSUInteger i = 0; i &lt; cnt; i++) &#123; id key = keys[i]; id obj = objects[i]; if (!key || !obj) &#123; continue; &#125; if (!obj) &#123; obj = [NSNull null]; &#125; safeKeys[j] = key; safeObjects[j] = obj; j++; &#125; return [self gl_initWithObjects:safeObjects forKeys:safeKeys count:j];&#125;@end@implementation NSMutableDictionary (Common)+ (void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; Class class = NSClassFromString(@&quot;__NSDictionaryM&quot;); [class gl_swizzleMethod:@selector(setObject:forKey:) withMethod:@selector(gl_setObject:forKey:)]; [class gl_swizzleMethod:@selector(setObject:forKeyedSubscript:) withMethod:@selector(gl_setObject:forKeyedSubscript:)]; &#125;);&#125;- (void)gl_setObject:(id)anObject forKey:(id&lt;NSCopying&gt;)aKey &#123; if (!aKey || !anObject) &#123; return; &#125; [self gl_setObject:anObject forKey:aKey];&#125;- (void)gl_setObject:(id)obj forKeyedSubscript:(id&lt;NSCopying&gt;)key &#123; if (!key || !obj) &#123; return; &#125; [self gl_setObject:obj forKeyedSubscript:key];&#125;@end","categories":[],"tags":[]},{"title":"Hexo+Github搭建个人博客","slug":"Hexo-Github搭建个人博客","date":"2019-04-02T02:58:52.000Z","updated":"2019-04-02T08:24:29.239Z","comments":true,"path":"2019/04/02/Hexo-Github搭建个人博客/","link":"","permalink":"http://yoursite.com/2019/04/02/Hexo-Github搭建个人博客/","excerpt":"","text":"作为一名程序员，个人觉得有一个自己的博客还是很有必要的。本文讲述如何通过Hexo+Github的方式快速搭建个人免费博客。本文主要针对macOS系统，Windows除了软件安装方式和命令行有些区别，其他基本一样。 1. 创建Github 域名和空间1.1注册首先你需要注册一个Github账号，已有的可以下翻去1.2 创建仓库，注意username，这会影响到你的域名，你的域名将会是 username.github.io ，所以认真的取个名字吧。注册过程可能需要验证你的邮箱，其他就不在赘述。 1.2创建仓库然后需要创建一个仓库(repository) 来存储我们的网站，点击首页任意位置出现的 New repository按钮创建仓库, Respository name 中的username.github.io 的username 一定与前面的Owner 一致，记住你的username下面会用到。 第一步就已经完成了，下面是安装。 2.安装Hexo 可以说是目前最流行的博客框架了，基于Nodejs，更多信息可以google，下面需要安装的工具包括 Git，Nodejs，Hexo。本文不在详述这些工具的安装，请自行百度。 3.编写发布接下来我们需要用Hexo初始化一个博客，然后更改一些自定义的配置，或者加上自己喜欢的主题，写上第一篇文章，然后发布到自己的个人Github网站 3.1创建博客将下面的 username 替换成你自己的username(其实也无所谓，作者强迫症)，执行成功后，会创建出一个名为 username.github.io 的文件夹。$ hexo init username.github.io 3.2更改配置主题安装为了使博客不太难看，我们需要安装一个主题，切换至刚刚生成的Hexo 目录，安装主题$ cd username.github.io$ git clone https://github.com/iissnan/hexo-theme-next themes/next这里选了一个极简的主题，也是Hexo众多主题中最受欢迎的一个。上面出现的喵神的主题 在这里。Hexo也有更多主题供你选择。 基础配置：打开文件位置username.github.io/_config.yml修改几个键值对，下面把几个必须设置的列出来按需求修改，记得保存， 还有注意配置的键值之间一定要有空格。更多设置… 1234567title: //你博客的名字author: //你的名字 language: zh-Hans //语言 中文 theme: next //刚刚安装的主题名称 deploy: type: git //使用Git 发布 repo: https://github.com/username/username.github.io.git // 刚创建的Github仓库 主题配置：主题配置文件在username.github.io/themes/next/_config.yml中修改，这里略过。设置详情 3.3写文章所有基础框架都已经创建完成，接下来可以开始写你的第一篇博客了$ hexo new post &#39;Hexo+Github搭建个人博客&#39;这样就在username.github.io/source/_posts下创建了名为’Hexo+Github搭建个人博客.md‘的文件，用Markdown编辑，并保存。 测试$ hexo s 测试服务启动，你可以在浏览器中输入https://localhost:4000 访问了。安装hexo-deployer-git自动部署发布工具$ npm install hexo-deployer-git --save 发布测试没问题后，我们就生成静态网页文件发布至我们的Github pages 中。 $ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 如果这是你的第一次，终端会让你输入Github 的邮箱和密码，正确输入后，骚等片刻，就会把你的博客上传至Github 了。以后在每次把博客写完后，执行一下这个命令就可以直接发布了，灰常苏胡。是不是很快，恭喜你能走到这一步，你的博客已经完成了，在浏览器中输入 http://username.github.io 就能够访问了。","categories":[],"tags":[]},{"title":"开始","slug":"开始","date":"2019-04-02T02:55:59.000Z","updated":"2019-04-02T02:56:37.621Z","comments":true,"path":"2019/04/02/开始/","link":"","permalink":"http://yoursite.com/2019/04/02/开始/","excerpt":"","text":"为了提高技术水平，养成写博客的习惯","categories":[],"tags":[]}]}